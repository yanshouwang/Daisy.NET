### 什么是委托

- 委托（delegate）是函数指针的“升级版”
    - 实例：C/C++ 中的函数指针
- 一切皆地址
    - 变量（数据）是以某个地址为起点的一段内存中所存储的值
    - 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令
- 直接调用与间接调用
    - 直接调用：通过函数名来调用函数，CPU 通过函数名直接获得函数所在地址并开始执行 -> 返回
    - 间接调用：通过函数指针来调用函数，CPU 通过读取函数指针存储的值来获得函数所在的地址并开始执行 -> 返回
- Java 中没有与委托相对应的功能实体
- 委托的简单使用
    - Action 委托
    - Func 委托

### 委托的声明（自定义委托）

- 委托是一种类（class），类是数据类型所以委托也是一种数据类型
- 它的声明方式与一般的类不同，主要是为了照顾可读性和 C/C++ 传统
- 注意声明委托的位置
    - 避免写错地方结果声明成嵌套类型
- 委托与所封装的方法必须“类型兼容”
    - 返回值的数据类型一致
    - 参数列表在个数和数据类型上一致（参数名不需要一样）

### 委托的一般使用

- 实例：把方法当作参数传给另一个方法
    - 正确使用 1：模板方法，“借用”指定的外部方法来产生结果
        - 相当于“填空题”
        - 常位于代码中部
        - 委托有返回值
    - 正确使用 2：回调方法，调用指定的外部方法
        - 相当于“流水线”
        - 常位于代码末端
        - 委托无返回值
- 注意：难精通 + 易使用 + 功能强大的东西，一旦被滥用则后果非常严重
    - 缺点 1：这是一种方法级别的紧耦合，现实工作中要慎之又慎
    - 缺点 2：使可读性下降，debug 的难度增加
    - 缺点 3：把委托回调，异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护
    - 缺点 4：委托使用不当有可能造成内存泄漏和程序性能下降

### 委托的高级使用
    
- 多播委托（multicast）
- 隐式异步调用
    - 同步与异步的简洁
        - 中英文的语言差异
        - 同步：你做完的（在你的基础上）我接着做
        - 异步：咱们两个同时做（相当于汉语中的“同时进行”）
    - 同步调用与异步调用的对比
        - 每一个运行的程序是一个进程（process）
        - 每个进程可以有一个或者多个线程（thread）
        - 同步调用是在同一线程内
        - 异步调用的底层机理是多线程
        - 串行 == 同步 == 单线程，并行 == 异步 == 多线程
    - 隐式多线程 VS 显式多线程
        - 直接同步调用：使用方法名
        - 间接同步调用：使用单播/多播委托的 Invoke 方法
        - 隐式异步调用：使用委托的 BeginInvoke 方法
        - 显示异步调用：使用 Thread 或 Task
- 应该适时地使用接口（interface）取代一些对委托的使用
    - Java 完全地使用接口取代了委托的功能，即 Java 没有与 C# 中委托相对于的功能实体
    